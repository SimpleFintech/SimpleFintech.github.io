<!DOCTYPE html>
<html>

<head>
  <meta http-equiv="Content-Type" content="text/html" charset="UTF-8" >
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"/>
  <title>JVM体系知识 (二) | Simple Fintech</title>
  <meta name="description" content="" />
  <meta name="HandheldFriendly" content="True" />
  <meta name="MobileOptimized" content="320" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <link rel="stylesheet" type="text/css" href="/css/screen.css" />
  <link rel="stylesheet" type="text/css" href="//fonts.googleapis.com/css?family=Noto+Serif:400,700,400italic|Open+Sans:700,400" />

  <meta name="generator" content="Simple Fintech">

  
  
  

  
</head>


<body class="post-template">

  <header class="site-head"  style="background-image: url(//blog.ghost.org/content/images/2013/Nov/cover.png)" >
    <div class="vertical">
        <div class="site-head-content inner">
             <a class="blog-logo" href="/"><img src="//blog.ghost.org/content/images/2013/Nov/bloglogo_1-1.png" alt="Blog Logo"/></a> 
            <h1 class="blog-title">Simple Fintech</h1>
            <h2 class="blog-description"></h2>
        </div>
    </div>
</header>
  

<main class="content" role="main">
  <article class="post">
    <span class="post-meta">
      <time datetime="2017-05-19T06:51:05.000Z" itemprop="datePublished">
          2017-05-19
      </time>
    
    
    | 
    <a href='/tags/JVM/'>JVM</a>
    
    
</span>
    <h1 class="post-title">JVM体系知识 (二)</h1>
    <section class="post-content">
      <blockquote>
<p>本文介绍了JVM相关基础知识，让开发者对JVM体系有一个大致的认识。主要介绍类的加载机制、类加载器、jvm内存结构、垃圾回收、JVM调优几个方面的知识。</p>
</blockquote>
<hr>
<p>目录</p>
<ol>
<li>类的加载机制</li>
<li>类加载器</li>
<li>jvm内存结构</li>
<li><strong>垃圾回收</strong></li>
<li><strong>JVM调优</strong></li>
</ol>
<hr>
<h5 id="四-GC"><a href="#四-GC" class="headerlink" title="四. GC"></a>四. GC</h5><blockquote>
<p>概述：jvm 中，程序计数器、虚拟机栈、本地方法栈都是随线程而生随线程而灭，栈帧随着方法的进入和退出做入栈和出栈操作，实现了自动的内存清理，因此，我们的内存垃圾回收主要集中于 java 堆和方法区中，在程序运行期间，这部分内存的分配和使用都是动态的.</p>
</blockquote>
<p>（1） 对象存活判断</p>
<blockquote>
<ul>
<li>引用计数：每个对象有一个引用计数属性，新增一个引用时计数加1，引用释放时计数减1，计数为0时可以回收。此方法简单，无法解决对象相互循环引用的问题。</li>
<li>可达性分析（Reachability Analysis）：从GC Roots开始向下搜索，搜索所走过的路径称为引用链。当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的。不可达对象。在Java语言中，GC Roots包括：<ul>
<li>虚拟机栈中引用的对象。<ul>
<li>方法区中类静态属性实体引用的对象。</li>
<li>方法区中常量引用的对象。</li>
<li>本地方法栈中JNI引用的对象。</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<p>（2） 垃圾收集算法</p>
<p><strong>“标记-清除”（Mark-Sweep）算法</strong>，算法分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收掉所有被标记的对象。</p>
<p>它的主要缺点有两个：一个是效率问题，标记和清除过程的效率都不高；另外一个是空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致，当程序在以后的运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。</p>
<p><strong>“复制”（Copying）的收集算法</strong>，它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。</p>
<p>这样使得每次都是对其中的一块进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。只是这种算法的代价是将内存缩小为原来的一半，持续复制长生存期的对象则导致效率降低。</p>
<p>复制收集算法在对象存活率较高时就要执行较多的复制操作，效率将会变低。更关键的是，如果不想浪费50%的空间，就需要有额外的空间进行分配担保，以应对被使用的内存中所有对象都100%存活的极端情况，所以在老年代一般不能直接选用这种算法。</p>
<p><strong>“标记-整理”（Mark-Compact）算法</strong>。根据老年代的特点，有人提出了另外一种“标记-整理”（Mark-Compact）算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。</p>
<blockquote>
<p>GC分代的基本假设：绝大部分对象的生命周期都非常短暂，存活时间短。</p>
</blockquote>
<p><strong>“分代收集”（Generational Collection）算法</strong>，把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。</p>
<ul>
<li>在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用<strong>复制算法</strong>，只需要付出少量存活对象的复制成本就可以完成收集。</li>
<li>而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用<strong>“标记-清理”或“标记-整理”算法</strong>来进行回收。</li>
</ul>
<p>（3）对象分配和回收</p>
<ol>
<li><p>永久代对象</p>
<ul>
<li>废弃无用的常量,例如：常量池中的字符串 “abc” 不再被任何字符串引用， 可以清除出去.</li>
<li>无用的类,该类的所有实例都被回收;加载该类的Classloader 已经被回收;该类对应的java.lang.Class对象没有任何地方被引用，无法在任何地方通过反射访问该类的方法;</li>
</ul>
</li>
<li><p>对象优先在新生代Eden分配</p>
<ul>
<li>如果Eden区域没有足够的空间， 就在新生代搞一次垃圾回收，称为minor GC</li>
<li>Java对象大多具有生命期短暂的特征， MinorGC 非常频繁， 速度也很快</li>
<li>大对象直接进入老年代。多大的对象？参数控制： -XX:PretenureSizeThreshold    </li>
</ul>
</li>
</ol>
<p>（4）垃圾收集器</p>
<p><strong>Serial收集器</strong> ，串行收集器是最古老，最稳定以及效率高的收集器，可能会产生较长的停顿，只使用一个线程去回收。新生代、老年代使用串行回收；新生代复制算法、老年代标记-压缩；垃圾收集的过程中会Stop The World（服务暂停）</p>
<blockquote>
<p>参数控制：-XX:+UseSerialGC  串行收集器</p>
</blockquote>
<p><strong>ParNew收集器</strong>，其实就是Serial收集器的多线程版本。新生代并行，老年代串行；新生代复制算法、老年代标记-压缩</p>
<blockquote>
<p>参数控制：<br>-XX:+UseParNewGC  ParNew收集器<br>-XX:ParallelGCThreads 限制线程数量</p>
</blockquote>
<p><strong>Parallel Scavenge收集器</strong>类似ParNew收集器，Parallel收集器更关注系统的吞吐量。可以通过参数来打开自适应调节策略，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或最大的吞吐量；也可以通过参数控制GC的时间不大于多少毫秒或者比例；新生代复制算法、老年代标记-压缩</p>
<blockquote>
<p>参数控制：-XX:+UseParallelGC  使用Parallel收集器+ 老年代串行</p>
</blockquote>
<p><strong>Parallel Old</strong>是Parallel Scavenge收集器的老年代版本，使用多线程和“标记－整理”算法。</p>
<blockquote>
<p>参数控制： -XX:+UseParallelOldGC 使用Parallel收集器+ 老年代并行</p>
</blockquote>
<p><strong>CMS（Concurrent Mark Sweep）收集器</strong>是一种以获取最短回收停顿时间为目标的收集器。目前很大一部分的Java应用都集中在互联网站或B/S系统的服务端上，这类应用尤其重视服务的响应速度，希望系统停顿时间最短，以给用户带来较好的体验。</p>
<p>从名字（包含“Mark Sweep”）上就可以看出CMS收集器是基于“标记-清除”算法实现的，它的运作过程相对于前面几种收集器来说要更复杂一些，整个过程分为4个步骤，包括： </p>
<blockquote>
<ul>
<li>初始标记（CMS initial mark）</li>
<li>并发标记（CMS concurrent mark）</li>
<li>重新标记（CMS remark）</li>
<li>并发清除（CMS concurrent sweep）</li>
</ul>
</blockquote>
<p>其中初始标记、重新标记这两个步骤仍然需要“Stop The World”。初始标记仅仅只是标记一下GC Roots能直接关联到的对象，速度很快，并发标记阶段就是进行GC Roots Tracing的过程，而重新标记阶段则是为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远比并发标记的时间短。 </p>
<p>由于整个过程中耗时最长的并发标记和并发清除过程中，收集器线程都可以与用户线程一起工作，所以总体上来说，CMS收集器的内存回收过程是与用户线程一起并发地执行。<br>优点:并发收集、低停顿<br>缺点：产生大量空间碎片、并发阶段会降低吞吐量</p>
<p>参数控制：</p>
<blockquote>
<ul>
<li>-XX:+UseConcMarkSweepGC  使用CMS收集器</li>
<li>-XX:+ UseCMSCompactAtFullCollection Full GC后，进行一次碎片整理；整理过程是独占的，会引起停顿时间变长</li>
<li>-XX:+CMSFullGCsBeforeCompaction  设置进行几次Full GC后，进行一次碎片整理</li>
<li>-XX:ParallelCMSThreads  设定CMS的线程数量（一般情况约等于可用CPU数量）</li>
</ul>
</blockquote>
<p><strong>G1收集器</strong><br>G1是目前技术发展的最前沿成果之一，HotSpot开发团队赋予它的使命是未来可以替换掉JDK1.5中发布的CMS收集器。与CMS收集器相比G1收集器有以下特点：</p>
<blockquote>
<ul>
<li>空间整合，G1收集器采用标记整理算法，不会产生内存空间碎片。分配大对象时不会因为无法找到连续空间而提前触发下一次GC。</li>
<li>可预测停顿，这是G1的另一大优势，降低停顿时间是G1和CMS的共同关注点，但G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为N毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒，这几乎已经是实时Java（RTSJ）的垃圾收集器的特征了。</li>
</ul>
</blockquote>
<hr>
<h5 id="五-jvm调优-待续）"><a href="#五-jvm调优-待续）" class="headerlink" title="五. jvm调优(待续）"></a>五. jvm调优(待续）</h5><p>jvm调优就是根据gc日志分析jvm内存分配、回收的情况来调整各区域内存比例或者gc回收的策略；更深一层就是根据dump出来的内存结构和线程栈来分析代码中不合理的地方给予改进。</p>
<p>（1）如何分析GC日志<br>摘录GC日志一部分：</p>
<p>2016-07-05T10:43:18.093+0800: 25.395: [GC [PSYoungGen: 274931K-&gt;10738K(274944K)] 371093K-&gt;147186K(450048K), 0.0668480 secs] [Times: user=0.17 sys=0.08, real=0.07 secs]</p>
<p>2016-07-05T10:43:18.160+0800: 25.462: [Full GC [PSYoungGen: 10738K-&gt;0K(274944K)] [ParOldGen: 136447K-&gt;140379K(302592K)] 147186K-&gt;140379K(577536K) [PSPermGen: 85411K-&gt;85376K(171008K)], 0.6763541 secs] [Times: user=1.75 sys=0.02, real=0.68 secs]</p>
<p>通过上面日志分析得出，PSYoungGen、ParOldGen、PSPermGen属于Parallel收集器。其中PSYoungGen表示gc回收前后年轻代的内存变化；ParOldGen表示gc回收前后老年代的内存变化；PSPermGen表示gc回收前后永久区的内存变化。young gc 主要是针对年轻代进行内存回收比较频繁，耗时短；full gc 会对整个堆内存进行回城，耗时长，因此一般尽量减少full gc的次数</p>
<p>通过两张图非常明显看出gc日志构成：</p>
<p><img src="http://i.imgur.com/WoOa19C.jpg" alt=""></p>
<p><img src="http://i.imgur.com/bvv3rCj.jpg" alt=""></p>

    </section>
    <footer class="post-footer">
      <section class="author">
    <h4>Simple Fintech</h4>
    <p>一个关于技术和金融知识的分享博客</p>
</section>
      <section class="share">
    <h4>Share this post</h4>
    <a class="icon-twitter" href="http://twitter.com/share?url=http://yoursite.com/2017/05/19/jvm-overview 2/"
       onclick="window.open(this.href, 'twitter-share', 'width=550,height=235');return false;">
        <span class="hidden">Twitter</span>
    </a>
    <a class="icon-facebook" href="https://www.facebook.com/sharer/sharer.php?u=http://yoursite.com/2017/05/19/jvm-overview 2/"
       onclick="window.open(this.href, 'facebook-share','width=580,height=296');return false;">
        <span class="hidden">Facebook</span>
    </a>
    <a class="icon-google-plus" href="https://plus.google.com/share?url=http://yoursite.com/2017/05/19/jvm-overview 2/"
       onclick="window.open(this.href, 'google-plus-share', 'width=490,height=530');return false;">
        <span class="hidden">Google+</span>
    </a>
</section>
    </footer>
  </article>
  <nav class="pagination" role="pagination">
    
    <a class="newer-posts" href="../React/">
        ← React
    </a>
    
    <span class="page-number">•</span>
    
    <a class="older-posts" href="../JVM体系知识/">
        JVM体系知识 (一) →
    </a>
    
</nav>
  <div id="comment" class="comments-area">
    <h1 class="title"><a href="#disqus_comments" name="disqus_comments">Comments</a></h1>

    
</div>
</main>


  
<footer class="site-footer">
  
  <div class="inner">
     <section class="copyright">All content copyright <a href="/">Simple Fintech</a> &copy; 2014 &bull; All rights reserved.</section>
     <section class="poweredby">Proudly published with <a class="icon-ghost" href="http://zespia.tw/hexo/">Hexo</a></section>
  </div>
</footer>

  <script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>

<script type="text/javascript" src="/js/jquery.fitvids.js"></script>
<script type="text/javascript" src="/js/index.js"></script>






</body>
</html>
