<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Simple Fintech</title>
  <meta name="author" content="Simple Fintech">
  
  <meta name="description" content="金融技术分享">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
  <meta property="og:site_name" content="Simple Fintech"/>

  
    <meta property="og:image" content="undefined"/>
  

  <link href="/favicon.png" rel="icon">
  <link rel="alternate" href="/atom.xml" title="Simple Fintech" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  

</head>


<body>
  <header id="header" class="inner"><div class="alignleft">
  <h1><a href="/">Simple Fintech</a></h1>
  <h2><a href="/"></a></h2>
</div>
<nav id="main-nav" class="alignright">
  <ul>
    
      <li><a href="/">Home</a></li>
    
      <li><a href="/archives">Archives</a></li>
    
  </ul>
  <div class="clearfix"></div>
</nav>
<div class="clearfix"></div>
</header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper">
  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2017-05-19T06:51:05.000Z"><a href="/2017/05/19/React/">2017-05-19</a></time>
      
      
  
    <h1 class="title"><a href="/2017/05/19/React/">React</a></h1>
  

    </header>
    <div class="entry">
      
        <blockquote>
<p>这里面有很多内容，但是可以分解：JSX，React Elements，Components，Lifecycle Methods, Props and State。</p>
</blockquote>
<h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><h3 id="React是什么"><a href="#React是什么" class="headerlink" title="React是什么"></a>React是什么</h3><p>React(或者React.js，或者ReactJS)是个开源的、用于构建interactive UI的JavaScript <strong>库</strong>，<br>最初的作者是Facebook的一名工程师<a href="https://twitter.com/jordwalke" target="_blank" rel="external">Jordan Walke</a>，<br>目前由Facebook，Instagram和其他一些公司以及独立开发者维护。</p>
<h3 id="React不是什么"><a href="#React不是什么" class="headerlink" title="React不是什么"></a>React不是什么</h3><h4 id="React不是MVC框架"><a href="#React不是MVC框架" class="headerlink" title="React不是MVC框架"></a>React不是MVC框架</h4><p>React不是一个框架，React仅仅处理应用中user interface相关部分，<br>对应于MVC结构中“V”的那部分，可以与其他框架或者库配合使用。</p>
<h4 id="React不使用templates"><a href="#React不使用templates" class="headerlink" title="React不使用templates"></a>React不使用templates</h4><p>React不使用模版或者HTML directive，而是通过分解为<strong>components</strong>来构建<br>用户界面，可以说提供了一种用来render view的语言。</p>
<ul>
<li>基于Javascript，具备构建Abstraction的能力，这对于大型程序很重要。</li>
<li>把Markup和对应的view逻辑放在一起，使得创建的views更易于维护、修改。</li>
<li>利用语言接口，避免手工拼接字符串，减少了XSS的风险。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;select</div><div class="line">  ng-model=<span class="string">"selectedItem"</span></div><div class="line">  ng-options=<span class="string">"item as item.name for item in items"</span>&gt;</div><div class="line">&lt;/select&gt;</div></pre></td></tr></table></figure>
<p>最后，React还提供了语法糖JSX，使得开发者可以用更熟悉的、可读性更强的HTML替代Javascript语句。</p>
<h3 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h3><h4 id="有什么不同"><a href="#有什么不同" class="headerlink" title="有什么不同"></a>有什么不同</h4><p>React处理Data变化的方式与传统Web应用不同。传统的JavaScript应用里，当data发生变化时，<br>你需要查看是什么数据变化了，然后以指令方式对DOM进行相应的修改，以保持界面跟数据的同步。</p>
<p>React采用的完全不同的策略。当component初始化时，<em>render</em>方法生成一个view——一段markup字符串，<br>插入到document中；当data发生变化时，<strong>再次调用<em>render</em>方法</strong>。<br>React会将本次调用render得到的view与上次调用render得到的结果进行比较，通过高效的diff<br>算法，<strong>算出最小修改集合</strong>，并应用到DOM上。</p>
<h4 id="一个实例"><a href="#一个实例" class="headerlink" title="一个实例"></a>一个实例</h4><h3 id="演进"><a href="#演进" class="headerlink" title="演进"></a>演进</h3><ul>
<li>原生Javascript</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> rootElement =</div><div class="line">  React.createElement(<span class="string">'div'</span>, &#123;&#125;,</div><div class="line">    React.createElement(<span class="string">'h1'</span>, &#123;<span class="attr">style</span>: &#123;<span class="attr">color</span>: <span class="string">'red'</span>&#125;&#125;, <span class="string">'The world is yours'</span>),</div><div class="line">    React.createElement(<span class="string">'p'</span>, &#123;&#125;, <span class="string">'Say hello to my little friend'</span>)</div><div class="line">  )</div><div class="line"></div><div class="line">ReactDOM.render(rootElement, <span class="built_in">document</span>.getElementById(<span class="string">'app'</span>))</div></pre></td></tr></table></figure>
<ul>
<li>JSX</li>
</ul>
<p>JSX是Facebook为不喜欢纯JavaScript代码的人搞的“语法糖”，下面的代码与上面等价。<br>在build阶段，<a href="https://babeljs.io/repl/#?babili=false&amp;evaluate=true&amp;lineWrap=false&amp;presets=es2015%2Creact%2Cstage-2&amp;targets=&amp;browsers=&amp;builtIns=false&amp;code=x" target="_blank" rel="external">Babel</a><br>会将Markup转译成JS代码。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> RootElement = (</div><div class="line">  &lt;div&gt;</div><div class="line">    &lt;h1&gt;The world is yours&lt;/h1&gt;</div><div class="line">    &lt;p&gt;Say hello to my little friend&lt;/p&gt;</div><div class="line">  &lt;/div&gt;</div><div class="line">)</div><div class="line"></div><div class="line">ReactDOM.render(RootElement, <span class="built_in">document</span>.getElementById(<span class="string">'app'</span>))</div></pre></td></tr></table></figure>
<h2 id="构成"><a href="#构成" class="headerlink" title="构成"></a>构成</h2><p>前文提到React提供了一种用来render view的语言，下面就从这种语言的原子构成、<br>抽象手段、组合手段三个方面分析React。</p>
<h3 id="原子构成"><a href="#原子构成" class="headerlink" title="原子构成"></a>原子构成</h3><ul>
<li><p>React Elements</p>
<p>上一节中的<figure class="highlight plain"><figcaption><span>Element。</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">  需要注意的是，这是**react** element，是JavaScript代码，而不是HTML element。</div><div class="line"></div><div class="line"></div><div class="line">### 抽象手段</div><div class="line">* React Components</div><div class="line"></div><div class="line">  Component是React的核心概念，典型的React代码就是一堆components。</div><div class="line">  那么什么是一个component呢？</div><div class="line">  一个典型的Component就是很常见的 ```&lt;select&gt;```，它不仅含有自身的可视化的部分，</div><div class="line">  同时还要处理它的点击展开、收回的逻辑。</div><div class="line"></div><div class="line">  ```js</div><div class="line">  &lt;select value=&#123;this.state.value&#125; onChange=&#123;this.handleChange&#125;&gt;</div><div class="line">    &#123;somearray.map(element =&gt; &lt;option value=&#123;element.value&#125;&gt;&#123;element.text&#125;&lt;/option&gt;)&#125;</div><div class="line">  &lt;/select&gt;</div></pre></td></tr></table></figure></p>
<p>最常用的创建React component的方法是写一个符合ES6的class，其中包含一个<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">该方法返回‘HTML’（实质上，是JSX）。另外，也可以通过更```functional```的方式创建component。</div><div class="line"></div><div class="line">```js</div><div class="line">class MyComponent extends React.Component &#123;</div><div class="line">  render() &#123;</div><div class="line">    return &lt;p&gt;Hello World!&lt;p&gt;;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li><p>Props<br>props，是‘properties’的缩写，是React component之间传递数据的手段。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ParentComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</div><div class="line">    render() &#123;</div><div class="line">      <span class="keyword">return</span> &lt;ChildComponent message="Hello World"/&gt;;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">class ChildComponent extends React.Component &#123;</div><div class="line">  render() &#123;</div><div class="line">    return &lt;p&gt;And then I said, “&#123;this.props.message&#125;”&lt;/p&gt;;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意，数据的流向是<strong>单向</strong>的，都是从父Component向子Component传递。</p>
</li>
<li><p>States<br>props是静态的，而states是在用户使用过程中动态变化的，是纪录这个‘变化’当前的值的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>(props) &#123;</div><div class="line">    <span class="keyword">super</span>(props);</div><div class="line">    <span class="keyword">this</span>.state = &#123;<span class="attr">clicked</span>: <span class="literal">false</span>&#125;;</div><div class="line">  &#125;</div><div class="line">  handleClick = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</div><div class="line">    <span class="keyword">this</span>.setState(&#123;<span class="attr">clicked</span>: <span class="literal">true</span>&#125;);</div><div class="line">  &#125;</div><div class="line">  render() &#123;</div><div class="line">    <span class="keyword">return</span> &lt;a href="#" onClick=&#123;this.handleClick&#125;&gt;Click me&lt;/a&gt;;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p><a href="https://facebook.github.io/react/docs/state-and-lifecycle.html" target="_blank" rel="external">Lifecycle Methods</a></p>
<p>在component特定的时间节点上（加载前、加载后、卸载。。。）可以作一些操作。</p>
</li>
</ul>
</li>
</ul>
<h3 id="组合手段"><a href="#组合手段" class="headerlink" title="组合手段"></a>组合手段</h3><ul>
<li><p>Composition</p>
<p>前面提到，使用React写的程序，就是由一个个Components组合而成的。通常可以将这些components<br>分为两类：Presentational Component 和 Container Component。</p>
<ul>
<li>presentational components：<ul>
<li>关注<strong>看起来什么样</strong></li>
<li>通常不依赖其他component</li>
<li>通常不需要state，不关心数据变化</li>
</ul>
</li>
<li>container components：<ul>
<li>关注<strong>如何交互</strong></li>
<li>为其他comopent提供data和行为（回调）</li>
<li>有状态的</li>
</ul>
</li>
</ul>
<p>这样分类，更加有利于复用。</p>
</li>
</ul>
<h2 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h2><h3 id="组件化"><a href="#组件化" class="headerlink" title="组件化"></a>组件化</h3><p>方便复用，逻辑更加清晰。</p>
<h3 id="函数式-immutable"><a href="#函数式-immutable" class="headerlink" title="函数式-immutable"></a>函数式-immutable</h3><p> (props) =&gt; view 全量更新</p>
<h3 id="Virtual-DOM-和-高效的Diff算法"><a href="#Virtual-DOM-和-高效的Diff算法" class="headerlink" title="Virtual DOM 和 高效的Diff算法"></a>Virtual DOM 和 高效的Diff算法</h3><p>  全量更新并不是真正地在DOM上操作，而是引入了一个额外的抽象层，叫作‘virtual dom’；<br>  全量更新的是’virtual DOM’层，然后在内存中比较更新前后的两个virtual DOM，运用<br>  高效的diff算法（类似于vim、git等采用的）计算出两者差异，再将差异的部分作用于DOM之上</p>
<blockquote>
<p>例子</p>
</blockquote>
<h2 id="工程化"><a href="#工程化" class="headerlink" title="工程化"></a>工程化</h2><h3 id="工具集"><a href="#工具集" class="headerlink" title="工具集"></a>工具集</h3><ul>
<li>依赖管理<ul>
<li>yarn</li>
</ul>
</li>
<li>Bundle<ul>
<li>webpack</li>
</ul>
</li>
<li>Test<ul>
<li>Jest</li>
<li>Snapshots</li>
<li>Enzyme</li>
</ul>
</li>
<li>Transpilation<ul>
<li>Babel</li>
</ul>
</li>
<li>Hot Module Reload<ul>
<li><a href="http://gaearon.github.io/react-hot-loader/" target="_blank" rel="external">React Hot Loader</a></li>
</ul>
</li>
<li>Browser extensions<ul>
<li><a href="https://github.com/facebook/react-devtools" target="_blank" rel="external">React Dev Tools</a></li>
</ul>
</li>
</ul>
<h3 id="Starter-Project"><a href="#Starter-Project" class="headerlink" title="Starter Project"></a>Starter Project</h3><ul>
<li>找一个<a href="http://andrewhfarmer.com/starter-project/" target="_blank" rel="external">合适的</a></li>
</ul>
<h2 id="资源-amp-参考"><a href="#资源-amp-参考" class="headerlink" title="资源&amp;参考"></a>资源&amp;参考</h2><ul>
<li><a href="https://facebook.github.io/react/docs/thinking-in-react.html" target="_blank" rel="external">Thinking in React - Pete Hunt</a></li>
<li><a href="https://medium.com/@ericclemmons/teaching-react-without-using-react-a4b87cfd4e87#.q8cyvryw1" target="_blank" rel="external">Teaching React Without Using React</a></li>
<li><a href="http://aimforsimplicity.com/post/13-things-you-need-to-know-about-react" target="_blank" rel="external">13 things you need to know about React</a></li>
<li><a href="https://medium.com/@sachagreif/the-5-things-you-need-to-know-to-understand-react-a1dbd5d114a3#.uii8of7um" target="_blank" rel="external">The 5 Things You Need To Know To Understand React</a></li>
<li><a href="https://medium.freecodecamp.com/yes-react-is-taking-over-front-end-development-the-question-is-why-40837af8ab76" target="_blank" rel="external">Yes, React is taking over front-end development. The question is why</a></li>
<li><a href="https://mva.microsoft.com/en-US/training-courses/introduction-to-react-16635?l=4wrKgdJrC_206218965" target="_blank" rel="external">Introduction to React Eric W. Greene / Microsoft Virtual Academy</a></li>
<li><a href="https://tylermcginnis.com/react-aha-moments/" target="_blank" rel="external">React “Aha” Moments</a></li>
<li><a href="https://egghead.io/lessons/react-react-in-7-minutes" target="_blank" rel="external">React in 7 Minutes</a></li>
</ul>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2017-05-19T06:51:05.000Z"><a href="/2017/05/19/jvm-overview1/">2017-05-19</a></time>
      
      
  
    <h1 class="title"><a href="/2017/05/19/jvm-overview1/">JVM体系知识一：类的加载、内存结构</a></h1>
  

    </header>
    <div class="entry">
      
        <blockquote>
<p>本文介绍了JVM相关基础知识，让开发者对JVM体系有一个大致的认识。</p>
<p>主要涉及类的加载机制、类加载器、jvm内存结构、垃圾回收、JVM调优几个方面的知识。</p>
</blockquote>
<hr>
<p>目录</p>
<ol>
<li>类的加载机制</li>
<li>类加载器</li>
<li>jvm内存结构</li>
</ol>
<hr>
<h5 id="一-类的加载机制"><a href="#一-类的加载机制" class="headerlink" title="一. 类的加载机制"></a>一. 类的加载机制</h5><p>1、 类的生命周期。 类加载的过程包括了<strong>加载，连接（验证、准备、解析），初始化</strong>五个阶段。</p>
<p>2、 <strong>类的加载</strong></p>
<p>（1）类的加载指的是将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后在堆区创建一个java.lang.Class对象，用来封装类在方法区内的数据结构。类的加载的最终产品是位于堆区中的Class对象，Class对象封装了类在方法区内的数据结构，并且向Java程序员提供了访问方法区内的数据结构的接口。</p>
<pre><code>例：Student s= new Student(),在内存中做了那些事情
    1. 加载Student.class 文件进内存
    2. 在栈内存为s开辟空间
    3. 在堆内存为Student对象开辟空间
    4. 学生对象的成员变量进行显示初始化
    5. 通过构造方法对Student对象变量赋值
    6. 学生对象初始完毕，把对象地址赋值给s变量
</code></pre><p>（2）在加载阶段，主要完成以下3点：</p>
<blockquote>
<ol>
<li>通过一个类的全限定名来获取定义此类的二进制字节流。</li>
<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</li>
<li>在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。</li>
</ol>
</blockquote>
<p>（3）常见得几种类的加载时机</p>
<blockquote>
<ol>
<li>遇到new、getstatic、putstatic或invokestatic这4条字节码指令，常见使用场景：使用new关键字，读取或设置一个类的静态字段（被final修饰、已在编译期把结果放入常量池的静态字段除外），调用一个类的静态方法的时候。</li>
<li>使用java.lang.reflect包</li>
<li>初始化一个类时，发现其父类还没有进行初始化，此时需要触发对其父类的初始化。</li>
<li>包含main方法的类</li>
<li>Java虚拟机启动时被标明为启动类的类（Java Test），直接使用java.exe命令来运行某个主类。</li>
</ol>
</blockquote>
<p>3、<strong>连接</strong></p>
<p>（1）验证：确保被加载的类的正确性。验证是连接阶段的第一步，这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。验证阶段大致会完成4个阶段的检验动作：文件格式验证,元数据验证,字节码验证,符号引用验证.</p>
<blockquote>
<p>验证阶段对程序运行期没有影响，如果所引用的类已经经过反复验证，那么可以考虑采用-Xverifynone参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。</p>
</blockquote>
<p>（2）准备：为类的静态变量分配内存，并将其初始化为默认值。</p>
<blockquote>
<ol>
<li>这时候进行内存分配的仅包括类变量（static），而不包括实例变量，实例变量会在对象实例化时随着对象一块分配在Java堆中。</li>
<li><p>这里所设置的初始值通常情况下是数据类型默认的零值（如0、0L、null、false等），而不是被在Java代码中被显式地赋予的值。</p>
<p>假设一个类变量的定义为：public static int value = 3；<br>那么变量value在准备阶段过后的初始值为0，而不是3，因为这时候尚未开始执行任何Java方法，而把value赋值为3的putstatic指令是在程序编译后，存放于类构造器<clinit>（）方法之中的，所以把value赋值为3的动作将在初始化阶段才会执行。</clinit></p>
</li>
</ol>
</blockquote>
<p>（3）解析：把类中的符号引用转换为直接引用。<br>符号引用就是一组符号来描述目标，可以是任何字面量。直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。</p>
<p>4、<strong>初始化</strong></p>
<p>为类的静态变量赋予正确的初始值，JVM负责对类进行初始化，主要对类变量进行初始化。在Java中对类变量进行初始值设定有两种方式：</p>
<ol>
<li>声明类变量是指定初始值</li>
<li>使用静态代码块为类变量指定初始值</li>
</ol>
<hr>
<h5 id="二-类加载器"><a href="#二-类加载器" class="headerlink" title="二. 类加载器"></a>二. 类加载器</h5><p>（1）启动类加载器：Bootstrap ClassLoader，负责加载存放在JDK\jre\lib(JDK代表JDK的安装目录，下同)下，或被-Xbootclasspath参数指定的路径中的，并且能被虚拟机识别的类库（如rt.jar，所有的java.*开头的类均被Bootstrap ClassLoader加载）。启动类加载器是无法被Java程序直接引用的。</p>
<p>（2）扩展类加载器：Extension ClassLoader，该加载器由sun.misc.Launcher$ExtClassLoader实现，它负责加载DK\jre\lib\ext目录中，或者由java.ext.dirs系统变量指定的路径中的所有类库（如javax.*开头的类），开发者可以直接使用扩展类加载器。</p>
<p>（3）应用程序类加载器：Application ClassLoader，该类加载器由sun.misc.Launcher$AppClassLoader来实现，它负责加载用户类路径（ClassPath）所指定的类，开发者可以直接使用该类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</p>
<p>应用程序都是由这三种类加载器互相配合进行加载的，如果有必要，我们还可以加入自定义的类加载器。因为JVM自带的ClassLoader只是懂得从本地文件系统加载标准的java class文件，因此如果编写了自己的ClassLoader，便可以做到如下几点：</p>
<blockquote>
<ol>
<li>在执行非置信代码之前，自动验证数字签名。</li>
<li>动态地创建符合用户特定需要的定制化构建类。</li>
<li>从特定的场所取得java class，例如数据库中和网络中。</li>
</ol>
</blockquote>
<p>（4）JVM类加载机制</p>
<blockquote>
<ol>
<li>全盘负责，当一个类加载器负责加载某个Class时，该Class所依赖的和引用的其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入</li>
<li>父类委托（双亲委托），先让父类加载器试图加载该类，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类</li>
<li>缓存机制，缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区寻找该Class，只有缓存区不存在，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓存区。这就是为什么修改了Class后，必须重启JVM，程序的修改才会生效</li>
</ol>
</blockquote>
<p>（5）双亲委托方式</p>
<p>双亲委派模型的工作流程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把请求委托给父加载器去完成，依次向上，因此，所有的类加载请求最终都应该被传递到顶层的启动类加载器中，只有当父加载器在它的搜索范围中没有找到所需的类时，即无法完成该加载，子加载器才会尝试自己去加载该类。</p>
<p><img src="http://i.imgur.com/9Jxeoo9.jpg" alt=""></p>
<blockquote>
<ol>
<li>当AppClassLoader加载一个class时，它首先不会自己去尝试加载这个类，而是把类加载请求委派给父类加载器ExtClassLoader去完成。</li>
<li>当ExtClassLoader加载一个class时，它首先也不会自己去尝试加载这个类，而是把类加载请求委派给BootStrapClassLoader去完成。</li>
<li>如果BootStrapClassLoader加载失败（例如在$JAVA_HOME/jre/lib里未查找到该class），会使用ExtClassLoader来尝试加载；</li>
<li>若ExtClassLoader也加载失败，则会使用AppClassLoader来加载，如果AppClassLoader也加载失败，则会报出异常ClassNotFoundException。</li>
</ol>
</blockquote>
<p>(6) 自定义加载器</p>
<p>下面来实现一个网络类加载器，这个加载器可以从网络上动态下载 .class 文件并加载到虚拟机中使用。</p>
<blockquote>
<ul>
<li>首先要继承 ClassLoader；</li>
<li>然后它要实现ClassLoader内的 findClass() 方法。注意，不是loadClass()方法，因为ClassLoader提供了loadClass()（如上面的源码），它会基于双亲委托机制去搜索某个 class，直到搜索不到才会调用自身的findClass()，如果直接复写loadClass()，那还要实现双亲委托机制；</li>
<li>在 findClass() 方法里，要从网络上下载一个 .class 文件，然后转化成 Class 对象供虚拟机使用。</li>
</ul>
</blockquote>
<hr>
<h5 id="三-java内存结构"><a href="#三-java内存结构" class="headerlink" title="三. java内存结构"></a>三. java内存结构</h5><p>JVM内存结构主要分为：</p>
<ul>
<li><strong>线程共享区：堆内存、方法区</strong>     </li>
<li><strong>线程私有区：程序计数器（pc），JVM栈，本地变量表、操作数栈</strong></li>
</ul>
<p><img src="http://i.imgur.com/WNm1l7T.png" alt=""></p>
<p>控制参数</p>
<pre><code>-Xms设置堆的最小空间大小。

-Xmx设置堆的最大空间大小。

-XX:NewSize设置新生代最小空间大小。

-XX:MaxNewSize设置新生代最大空间大小。

-XX:PermSize设置永久代最小空间大小。

-XX:MaxPermSize设置永久代最大空间大小。

-Xss设置每个线程的堆栈大小。
</code></pre><p>（1）堆内存是JVM中最大的一块由年轻代和老年代组成，而年轻代内存又被分成三部分，Eden空间、From Survivor空间、To Survivor空间,默认情况下年轻代按照8:1:1的比例来分配。</p>
<p>（2）方法区存储类信息、常量、静态变量等数据，是线程共享的区域，为与Java堆区分，方法区还有一个别名Non-Heap(非堆)；栈又分为java虚拟机栈和本地方法栈主要用于方法的执行。对于习惯在HotSpot虚拟机上开发和部署程序的开发者来说，很多人愿意把方法区称为“永久代”（Permanent Generation），本质上两者并不等价，仅仅是因为HotSpot虚拟机的设计团队选择把GC分代收集扩展至方法区，或者说使用永久代来实现方法区而已。</p>
<p>（3）程序计数器（PC）。当一个线程从可运行状态得到CPU调度进入运行状态，CPU需要知道从哪里开始执行。当执行一个java方法时，pc会窒息下一条指令位置。</p>
<p>（3）JVM栈。与程序计数器一样，Java虚拟机栈（Java Virtual Machine Stacks）也是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的内存模型：每个方法被执行的时候都会同时创建一个栈帧（Stack Frame）用于<br><strong>存储局部变量表、操作栈、动态链接、方法出口</strong>等信息。每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。 本地变量表存储方法的参数、方法内部创建的局部变量。操作数栈用于方法内执行保存中间结果，Java方法中的代码逻辑就是通过操作数栈来实现的。和本地方法表一样，操作数栈也是在编译时就确定最大大小了，即最大深度。操作数栈可以和本地变量表交互，进行数据的存放和读取。</p>
<p>在Java虚拟机规范中，对这个区域规定了两种异常状况：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常；如果虚拟机栈可以动态扩展（当前大部分的Java虚拟机都可动态扩展，只不过Java虚拟机规范中也允许固定长度的虚拟机栈），当扩展时无法申请到足够的内存时会抛出OutOfMemoryError异常。</p>
<p>(4) 本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的Native方法服务。有的虚拟机（譬如Sun HotSpot虚拟机）直接就把本地方法栈和虚拟机栈合二为一。</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2017-05-19T06:51:05.000Z"><a href="/2017/05/19/jvm-overview2/">2017-05-19</a></time>
      
      
  
    <h1 class="title"><a href="/2017/05/19/jvm-overview2/">JVM体系知识二：GC相关</a></h1>
  

    </header>
    <div class="entry">
      
        <blockquote>
<p>本文介绍了JVM相关基础知识，让开发者对JVM体系有一个大致的认识。</p>
<p>主要涉及类的加载机制、类加载器、jvm内存结构、垃圾回收、JVM调优几个方面的知识。</p>
</blockquote>
<hr>
<p>目录</p>
<ol>
<li>垃圾回收</li>
<li>JVM调优</li>
</ol>
<hr>
<p>#####一. GC </p>
<blockquote>
<p>概述：jvm 中，程序计数器、虚拟机栈、本地方法栈都是随线程而生随线程而灭，栈帧随着方法的进入和退出做入栈和出栈操作，实现了自动的内存清理，因此，我们的内存垃圾回收主要集中于 <strong>java 堆和方法区</strong>中，在程序运行期间，这部分内存的分配和使用都是动态的。</p>
</blockquote>
<p><img src="http://i.imgur.com/TtZiWqb.jpg" alt=""></p>
<blockquote>
<p>一般来说，当某个区域内存不够的时候就会进行垃圾收集。如当Eden区域分配不下对象时，就会进行年轻代的收集。还有其他的情况，如使用CMS收集器时配置CMSInitiatingOccupancyFraction设置什么时候触发Old区的回收。</p>
</blockquote>
<hr>
<p>######（1） 对象存活判断</p>
<ul>
<li>引用计数：每个对象有一个引用计数属性，新增一个引用时计数加1，引用释放时计数减1，计数为0时可以回收。此方法简单，无法解决对象相互循环引用的问题。</li>
<li>可达性分析（Reachability Analysis）：从GC Roots开始向下搜索，搜索所走过的路径称为引用链。当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的。不可达对象。在Java语言中，GC Roots包括：<ul>
<li>虚拟机栈中引用的对象。<ul>
<li>方法区中类静态属性实体引用的对象。</li>
<li>方法区中常量引用的对象。</li>
<li>本地方法栈中JNI引用的对象。</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<p>######（2） 垃圾收集算法</p>
<p><strong>“标记-清除”（Mark-Sweep）算法</strong>，算法分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收掉所有被标记的对象。</p>
<p>它的主要缺点有两个：一个是效率问题，标记和清除过程的效率都不高；另外一个是空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致，当程序在以后的运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。</p>
<p><strong>“复制”（Copying）的收集算法</strong>，它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。</p>
<p>这样使得每次都是对其中的一块进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。只是这种算法的代价是将内存缩小为原来的一半，持续复制长生存期的对象则导致效率降低。</p>
<p>复制收集算法在对象存活率较高时就要执行较多的复制操作，效率将会变低。更关键的是，如果不想浪费50%的空间，就需要有额外的空间进行分配担保，以应对被使用的内存中所有对象都100%存活的极端情况，所以在老年代一般不能直接选用这种算法。</p>
<p><strong>“标记-整理”（Mark-Compact）算法</strong>。根据老年代的特点，有人提出了另外一种“标记-整理”（Mark-Compact）算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。</p>
<p><strong>“SUN HotSpot分代收集”（Generational Collection）算法</strong>，把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。</p>
<blockquote>
<p>GC分代的基本假设：绝大部分对象的生命周期都非常短暂，存活时间短。</p>
</blockquote>
<p><img src="http://i.imgur.com/odArvRK.jpg" alt=""></p>
<hr>
<p>######（3）垃圾收集器</p>
<p><img src="http://i.imgur.com/LmhWgFZ.jpg" alt=""></p>
<p>新生代GC</p>
<ul>
<li>均使用<strong>复制</strong>算法，原理上是一致的：<ul>
<li>拷贝eden和from中的存活对象到to中 </li>
<li>部分对象由于某些原因晋升到old中</li>
<li>清空eden、from区，from和to交换身份直到下一次GC发生 </li>
</ul>
</li>
<li>分配对象时，Eden空间不足时触发。</li>
</ul>
<p>年老代GC</p>
<ul>
<li>老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用<strong>“标记-清理”或“标记-整理”算法</strong>来进行回收</li>
</ul>
<hr>
<h5 id="二-调优"><a href="#二-调优" class="headerlink" title="二. 调优"></a>二. 调优</h5><p>jvm调优就是根据gc日志分析jvm内存分配、回收的情况来调整各区域内存比例或者gc回收的策略；更深一层就是根据dump出来的内存结构和线程栈来分析代码中不合理的地方给予改进。</p>
<p>（1）准则</p>
<pre><code>- 堆大小的调优
    1. 一般来说越大越好（降低GC频率，但过大可能会增加单次GC时间）。
    2. 受硬件和操作系统限制。32位操作系统单进程最大可用内存为2G。
    3. 堆每次调整都会触发一次Full GC, 避免频繁调整，可以设置-Xms = -Xmx，但也不是决对。
    4. 如果内存允许，可以把-Xmx设置为一个比-Xms更大的数值。
    5. 进行一次Full GC 总比 发送OOM &amp; 宕机好。
- 新生代调优
    1. 增加Eden大小会降低Minor GC的频率，但不一定会增大Minor GC的频率（耗时和存活对象多少成正比）。
    2. 处于性能考虑，一般使用-Xmn来固定新生代大小。-Xmn=1024MB : 新生代大小。
    3. 尽可能让对象呆在Survior中，使之在新生代被回收，降低老年代GC频率（better copy more ,than promote more）。-XX:SurvivorRatio=m : Eden 和 Survivor的比值。
    4. 对象晋升（promotion）年龄的阈值。年龄标志位age，每熬过一轮gc对象年龄加1，查看每次minor GC后年龄的分布和计算出来的阈值： -XX:+PrintTenuringDistruibution
- 旧生代调优
    1. 尽可能调优新生代
    2. （对CMS)在不要紧的时段手动进行full gc
    3. 大小的平衡：太大——单次gc时间长；太小——gc频率高
    4. 硬件和程序的优化（去掉不必要的缓存）
</code></pre><p>（2）监控</p>
<pre><code>- JVM
    1. -XX:+PrintGC 输出GC简要信息
    2. -XX:+PrintGCDetails 输出GC详细信息
    3. -XX:+printGCTimeStamps 输出GC时间戳
    4. -XX:+PrintGCapplicationStoppedTime 输出GC暂停时间
    5. -Xlogg c:/gc.log 输出到文件

- 查看内存使用 ： jmap + jhat
- 查看GC情况：jstat
</code></pre><p>（3）如何分析GC日志<br>摘录GC日志一部分：</p>
<p>2016-07-05T10:43:18.093+0800: 25.395: [GC [PSYoungGen: 274931K-&gt;10738K(274944K)] 371093K-&gt;147186K(450048K), 0.0668480 secs] [Times: user=0.17 sys=0.08, real=0.07 secs]</p>
<p>2016-07-05T10:43:18.160+0800: 25.462: [Full GC [PSYoungGen: 10738K-&gt;0K(274944K)] [ParOldGen: 136447K-&gt;140379K(302592K)] 147186K-&gt;140379K(577536K) [PSPermGen: 85411K-&gt;85376K(171008K)], 0.6763541 secs] [Times: user=1.75 sys=0.02, real=0.68 secs]</p>
<p>通过上面日志分析得出，PSYoungGen、ParOldGen、PSPermGen属于Parallel收集器。其中PSYoungGen表示gc回收前后年轻代的内存变化；ParOldGen表示gc回收前后老年代的内存变化；PSPermGen表示gc回收前后永久区的内存变化。young gc 主要是针对年轻代进行内存回收比较频繁，耗时短；full gc 会对整个堆内存进行回城，耗时长，因此一般尽量减少full gc的次数</p>
<p>通过两张图非常明显看出gc日志构成：</p>
<p><img src="http://i.imgur.com/WoOa19C.jpg" alt=""></p>
<p><img src="http://i.imgur.com/bvv3rCj.jpg" alt=""></p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





<nav id="pagination">
  
  
  <div class="clearfix"></div>
</nav></div></div>
    <aside id="sidebar" class="alignright">
  <div class="search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" name="q" results="0" placeholder="搜索">
    <input type="hidden" name="q" value="site:yoursite.com">
  </form>
</div>

  

  
<div class="widget tag">
  <h3 class="title">标签</h3>
  <ul class="entry">
  
    <li><a href="/tags/JAVASCRIPT/">JAVASCRIPT</a><small>1</small></li>
  
    <li><a href="/tags/JVM/">JVM</a><small>2</small></li>
  
  </ul>
</div>

</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">
  
  &copy; 2017 Simple Fintech
  
</div>
<div class="clearfix"></div></footer>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>




<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>

</body>
</html>
